 //todo SOME

Strutture DATI
type var = { dummy : unit }
type node =
    { mutable content : term
    ; mutable copying : bool
    ; mutable prev : node option }
and env = ( node * node ) option
and crumblep = term * env
and term =
    | Err
    | True
    | False
    | Var of var
    | Lam of var * crumblep
    | App of term * term
    | IfThenElse of term * crumblep * crumblep
    | Shared of node

let mk_node content = { content ; copying = false ; prev = None } //todo

let push n e = n. prev <- Some e

type 'a option -- none | some of 'a

EVAL Caso Aperto
let rec eval_o n =
    match n. content with
    | App ( Lam (y ,c), t) ->
        (* β f *)
        let y ' = mk_node t in
        let c ' = copy_crumb y y ' c in
        push y ' (n @ c ') ;
        eval_o y '
    | App ( Shared { content = ( Lam _| True | False | Err ) as t1 }, t2 ) ->
        (* e l *)
        n . content <- App (t1 , t2 );
        eval_o n
    | App (( True | False | Err ), _) ->
        (* @e *)
        n. content <- Err ;
        eval_o n
    | IfThenElse ( True ,c ,_) (* ift *)
    | IfThenElse ( False ,_ ,c) (* iff *)->
        eval_o (n @ c)
    | IfThenElse( Shared { content =( Lam _| True | False | Err ) as t1 }, t2 , t3 ) ->
        (* e if *)
        n. content <-
        IfThenElse (t1 ,t2 , t3 ) ;
        eval_o n
    | IfThenElse (( Lam _| Err ),_ ,_) ->
        (* ife *)
        n. content <- Err ;
        eval_o n
    | Shared { content =
        ( Lam _| True | False | Err )} ->
        (* e var *)
        n. content <- content ;
        pop n
    | Lam _ | Err | True | False ->
        (* c *)
        pop n
    | Var _ | App ( Var _ , _)
    | Shared _ | App ( Shared _ , _)
    | IfThenElse ( Var _ ,_ ,_) ->
        (* c *)
        pop n
    | _ -> assert false


COPY_CRUMBP
let copy_crumb v n =
    let rec copy = function
        | Var v ' when v == v ' -> Shared n
        | Shared { content ; copying } when copying -> content
        | Err | True | False | Var _ | Shared _ as c -> c
        | App ( c1 , c2 ) -> App ( copy c1 , copy c2 )
        | IfThenElse (c ,p ,q) -> IfThenElse ( copy c , copy_crumbp p , copy_crumbp q)
        | Lam (v , e ) -> Lam (v , copy_crumbp e)
    and copy_env c e =
        let n ' = mk_node ( copy e. content ) in
        copying_node e n ' ( fun () ->
        match e . prev with
            | None -> copy c , n ' , n '
            | Some prev ->
                let c ' ,b ' ,e ' = copy_env c prev in
                push n ' e ' ;
                c ',b ' ,n ')
    and copy_crumbp (c ,e) =
        match e with
            None -> copy c , None
            | Some (b , e ) -> let c ' ,b ' ,e ' = copy_env c e in c ' , Some (b ' ,e ')
in copy_crumbp n


ANF

prende un ambiente non valutato e restituisce il corrispondente ambiente non valutato e sbriciolato.
let anf p =
//traduce c in q = (d, e'), aggiunge e' ad e e restituisce la coppia di crumble ottenuta.
    let rec aux_term c e = match c with
        | Var _ | Err | True | False ->
                c , e
        | App (v , w ) ->
            let v , e = aux_val v e in
            let w , e = aux_val w e in
                App (v , w ) , e
        | IfThenElse (v , p , q) ->
            let c , e = aux_val v e in
            let p = aux_crumbp p in
            let q = aux_crumbp q in
                IfThenElse (c ,p ,q), e
        | Lam (x , p ) ->
                Lam (x , aux_crumbp p), e
        | Shared n ->
                n. content , e

    //controlla che c sia un valore, calcolando ·, o ·  chiamando aux_term c e.
    and aux_val c e = match c with
        | App _ | IfThenElse _ ->
            let n = mk_node dummy in
            let b =
            ( match e with
                None -> n
                | Some (b ,e) -> insert_after n e ; b )
            in
            let c , e = aux_term c ( Some (b ,n )) in
            n . content <- c;
            Shared n , e
        | Var _ | Lam _ | Shared _ | Err | True | False ->
            aux_term c e

    //crea una copia di (c, e) in forma sgretolata in tempo lineare
    //riutilizzando lo stesso trucco del flag di copia come in α-renaming.
    and aux_env c e =
        let p = aux_term e. content None in
        match e . prev with
            | None ->
                aux_term ( snd p) c
            | Some prev ->
                let n = mk_node dummy in
                let last = n @ p in
                let (c , env ) = copying_node e n ( fun () -> aux_env c prev ) in
                ( match env with
                    None ->
                        c , Some (n , last )
                    | Some (b ,e) ->
                        insert_after n e ;
                        c , Some (b , last )
                )

    and aux_crumbp (c , env ) =
        match env with
            None ->
                aux_term c None
            | Some (_ , e ) ->
                aux_env c e
    in
iota ( aux_crumbp p)






aux_value c e

(3) aux_env











let dummy = Var ( mk_var ())

let iota e =
    let star = mk_node dummy in
    star @ e



let ( @ ) n (c , env ) = //todo
    n. content <- c ;
    match env with
        None -> n
        | Some (b , e ) -> push b n ; e



COPYING_NODE
let copying_node y y ' f =
    let saved = y . content in
    y. content <- Shared y ' ;
    y. copying <- true ;
    let res = f () in
    y. content <- saved ;
    y. copying <- false ;
    res //todo
