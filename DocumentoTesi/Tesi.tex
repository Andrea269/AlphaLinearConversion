%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%12pt: grandezza carattere
                                        %a4paper: formato a4
                                        %openright: apre i capitoli a destra
                                        %twoside: serve per fare un
                                        %   documento fronteretro
                                        %report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per scrivere in italiano
\usepackage[italian]{babel}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per accettare i caratteri
                                        %   digitati da tastiera come Ã¨ Ã 
                                        %   si puÃ² usare anche
                                        %   \usepackage[T1]{fontenc}
                                        %   perÃ² con questa libreria
                                        %   il tempo di compilazione
                                        %   aumenta
\usepackage[latin1]{inputenc}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per impostare il documento
\usepackage{fancyhdr}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per avere l'indentazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   all'inizio dei capitoli, ...
\usepackage{indentfirst}
%
%%%%%%%%%libreria per mostrare le etichette
%\usepackage{showkeys}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per inserire grafici
\usepackage{graphicx}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per utilizzare font
                                        %   particolari ad esempio
                                        %   \textsc{}
\usepackage{newlfont}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%librerie matematiche
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{tikz}%%%% per grafi
%
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini
\hyphenation{sil-la-ba-zio-ne pa-ren-te-si}%serve per la sillabazione: tra parentesi 
					   %vanno inserite come nell'esempio le parole 
%					   %che latex non riesce a tagliare nel modo giusto andando a capo.

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%comandi per l'impostazione
                                        %   della pagina, vedi il manuale
                                        %   della libreria fancyhdr
                                        %   per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\linespread{1.3}                        %comando per impostare l'interlinea
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%definisce nuovi comandi
%

% Macro
\newcommand\match{\mathtt{Match}}


\begin{document}
\begin{titlepage}                       %crea un ambiente libero da vincoli
                                        %   di margini e grandezza caratteri:
                                        %   si pu\`o modificare quello che si
                                        %   vuole, tanto fuori da questo
                                        %   ambiente tutto viene ristabilito
%
\thispagestyle{empty}                   %elimina il numero della pagina
\topmargin=6.5cm                        %imposta il margina superiore a 6.5cm
\raggedleft                             %incolonna la scrittura a destra
\large                                  %aumenta la grandezza del carattere
                                        %   a 14pt
\em                                     %emfatizza (corsivo) il carattere
Questa \`e la \textsc{Dedica}:\\
ognuno pu\`o scrivere quello che vuole, \\
anche nulla \ldots                      %\ldots lascia tre puntini
\newpage                                %va in una pagina nuova
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}%non numera l'ultima pagina sinistra
\end{titlepage}
\pagenumbering{roman}                   %serve per mettere i numeri romani
\chapter*{Abstract}                 %crea l'introduzione (un capitolo
                                        %   non numerato)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
ABSTRACT}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
ABSTRACT}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Introduzione
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Abstract}
Lo studio presente in questo documento \`e il frutto di una ricerca pi\`u ampia condotta da Accattoli, Condoluci e Sacerdoti Coen ed esposto nel documento Sharing Equality is Linear  \cite{K1}.\newline
Il lavoro svolto consiste in un'implementazione efficiente delle regole di riduzione di un $\lambda$-termine, codificando le stesse in un algoritmo, seguite dall'applicazione di tali regole per ridurre e comparare due $\lambda$-espressioni apparentemente differenti. L'output di tale algoritmo \`e un feedback che riporta se tali espressioni sono effettivamente differenti o se rappresentano la stessa espressione ridotta. Due $\lambda$-espressioni vengono considerate equivalenti a meno di un $\alpha-rinominazione$ ovvero di comparare i $\lambda$-termini a meno dei nomi delle variabili ad essi legate. Quindi due $\lambda$-espressioni equivalenti verranno considerate bi-simili.\newline
Lo studio presente nel documento Sharing Equality is Linear  \cite{K1} si basa su precedenti lavori condotti da Accattoli e Dal Lago ed esposti nel documento NOME\_DOC  \cite{K2}, nel quale viene dimostrato che la riduzione forte di un $\lambda$-termine \`e consentita ovunque ed \`e ragionevole implementare un algoritmo che la esegua. \newline
L'algoritmo ideato da Accattoli et alt. \`e ispirato all'algoritmo di Paterson e Wegman \cite{K3} per l'unificazione del primo ordine dove i $\lambda$-termini delle $\lambda$-espressioni vengono rappresentati sotto forma di DAG (Directed Acyclic Graph - Grafo Aciclico Diretto).\newline
Nel seguito del documento verranno illustrate le regole di riduzione, i costrutti e le tecniche utilizzate nell'implementazione dell'algoritmo.\newline






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents                        %crea l'indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Introduzione}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
Il progetto di tesi svolto consiste nella realizzazione di un algoritmo per la visita e la riduzione di $\lambda$-espressioni, per permetterne la comparazione e quindi determinare se due $\lambda$-espressioni sono bi-simili.\newline
Le $\lambda$-espressioni prese in considerazione sono un formalismo per descrivere un programma software, nonch\'e il fine ultimo dell'algoritmo \`e determinare se 2 programmi, a parit\`a di input, producono lo stesso output senza eseguire tali programmi.\newline
La modalit\`a di rappresentazione delle $\lambda$-espressioni \`e la stessa suggerita da Paterson e Wegman ossia tramite un grafo aciclico diretto. Tale rappresentazione \`e risultata essere ottimale allo scopo prefissato poich\'e  permette di creare una gerarchia fra i $\lambda$-termini dell'espressione e quindi determinare padri e figli di un termine in modo naturale.\newline

L'algoritmo implementato consiste in una procedura che prende in input due $\lambda$-espressioni e ne compara i $\lambda$-termini sottostanti tramite una relazione di vicinato ($\sim$neighbour).\newline
Ogni $\lambda$-espressione \`e codificata tramite un DAG e ogni nodo di tale grafo \`e inserito in un array globale utilizzato per visitare esattamente una volta ogni nodo. L'algoritmo pu\`o iniziare la valutazione da un qualsiasi nodo del DAG e tramite procedure ad-hoc risale sino al nodo root per poi iniziare la comparazione con il secondo DAG.\newline

La particolarit\`a legata al progetto in esame \`e di eseguire tale comparazione in tempo lineare al numero di nodi presenti nell'array globale. Tale vincolo non \`e banale poich\'e l'algoritmo deve riuscire a visitare esattamente una volta ogni nodo e determinare se il $\sim$neighbour corrispondente rappresenta in realt\`a lo stesso termine ridotto a meno di $\alpha-rinominazione$. Nel \textit{Capitolo 4 Algoritmo - AlphaLinearConversion} vedremo come tale relazione viene semplificata attraverso la definizione di un nodo canonico per ogni nodo. Tale canonico sar\`a il nodo stesso o il $\sim$neighbour corrispondente nell'altra $\lambda$-espressione, sempre che non accada prima che l'algoritmo rifiuti la comparazione perch\'e ha rilevato che i 2 DAG presi in input non sono bi-simili.\newline

Un'ulteriore particolarit\`a \`e che la comparazione e la valutazione avvengano in parallelo, ovvero non vi \`e una vera \`e propria parallelizzazione dell'esecuzione, ma mentre analizza un termine per compararlo con i suoi $\sim$neighbour, se questo non \`e stato ancora valutato, verr\`a richiamata la procedura di valutazione. Un approccio di questo tipo permette di ottenere in minor tempo una risposta dall'algoritmo nel caso in cui non siano bi-simili poich\'e non vengono valutati tutti i termini.\newline

I costrutti implementati nell'algoritmo comprendono tutti i costrutti tipici di un linguaggio funzionale e sono stati opportunamente codificati tramite nodi del grafo. Suddetti costrutti sono:
\begin{itemize}                         %crea un elenco puntato
\item variabili libere da contesto: $x$;
\item variabili legate ad un ambiente chiamate binders: $b$;
\item applicazioni per rappresentare un operazione binaria: $t@t$
\item $\lambda$-astrazioni: $\lambda\>x:t.t$;
\item sorte: $s$;
\item tipi induttivi: $i$;
\item costruttori j-esimo con n argomenti: $k_j[s_1, ..., s_n]$;
\item costanti non definite in libreria: $a$;
\item costanti definite in libreria: $c$;
\item match: $match\> i\> t_0\> t\> \Vec{t_{i}}$;
\item piai (tipo delle funzioni): $\Pi\> x:t.t$;
\item let per la dichiarazione di variabili locali o per abbreviazioni: \newline$Let\> x:t:=t\> in\> t$;
\item funzioni ricorsive: $f^{(n)}\> [t_1, ..., t_n]$;
\item funzioni co-ricorsive: $g^{(n)}\> [t_1, ..., t_n]$.
\end{itemize}

Suddetti costrutti verranno descritti formalmente nel \textit{Capitolo 4 Algoritmo - AlphaLinearConversion} ma alcuni di questi verranno nominati nel \textit{Capitolo 2 Regole di riduzione} per descrivere le regole di riduzione coinvolte nella loro valutazione.\newline

Il linguaggio scelto per l'implementazione \`e stato C. Tale scelta \`e motivata dalle feature offerte dal linguaggio, ossia non aggiunge alcun overhead computazionale garantendo di preservare la complessit\`a programmata e permette la gestione esplicita della memoria. Quest'ultima feature \`e stata utilizzata per identificare univocamente un nodo tramite il suo indirizzo di memoria evitando un overhead procedurale, come ad esempio il calcolo dell'hash del nodo, inoltre l'utilizzo dei puntatori facilita notevolmente lo sharing dei nodi.\newline



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Regole di riduzione}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
Il $\lambda$-calcolo \`e un pratico formalismo per la traduzione di un programma software in un'espressione. Ci\`o permette di applicare procedure deterministiche per la valutazione dei termini della $\lambda$-espressione. Tale formalismo consente inoltre di sostituire parti dell'espressione con forme ridotte della stessa. Ridurre un $\lambda$-termine non significa ridurre il numero di componenti ma trasformare tale termine in un nuovo termine per semplificare il calcolo.\newline
Le riduzioni che permettono tali sostituzioni sono state opportunamente formalizzate dal professore Sacerdoti Coen Claudio, relatore di questa tesi, e opportunamente codificate nell'algoritmo oggetto di codesta tesi. Di seguito verranno presentate tali riduzioni.\newline

$\beta$-riduzione

La $\beta$-riduzione \`e applicabile quando si valuta un $\lambda$-termine applicazione che ha come $\lambda$-termine figlio sinistro una $\lambda$-astrazione. Dopo aver applicato la $\beta$ il nodo applicazione verr\`a sostituito da un nuovo nodo formato dal $\lambda$-termine figlio destro della $\lambda$-astrazione, il quale sar\`a collegato alla variabile legata all'astrazione (il binder). In seguito verr\`a settato come figlio del binder il nodo destro del nodo applicazione.\newline
Formalmente: $( \lambda x:T.t)M \rightarrow_\beta t [M/x]$\newline

Quando si valuta un $\lambda$-termine match \`e possibile applicare due tipi di riduzione a seconda del $\lambda$-termine contenuto nel body del match. Le riduzioni applicabili sono la J-riduzione o la J$\delta$c-riduzione.\newline

J-riduzione

La J-riduzione \`e applicabile quando il body \`e un $\lambda$-termine costruttore j-esimo. In questo caso verr\`a sostituito l'intero nodo match con una serie di nodi applicazione costruiti in modo ricorsivo come segue. L'applicazione foglia Aj avr\`a come figlio destro il termine s1 del costruttore e come figlio sinistro il ramo tj del nodo match. L'applicazione al livello immediatamente dopo avr\`a come figlio sinistro l'applicazione Aj e come figlio destro il nodo s2 del costruttore. La costruzione continua in modo iterativo fino all'applicazione che avr\`a come figlio destro il nodo sk del costruttore. Quest'ultimo nodo applicazione sar\`a il nodo che sostituir\`a il nodo match.\newline
Formalmente: $Match\> i\> t_0\> (k_j [s_1, ..., s_k])\> \Vec{t_{i}}\> \rightarrow_J \> t_j\> s_1, ..., s_k$\newline

J$\delta$c-riduzione

La J$\delta$c-riduzione \`e applicabile quando il body del nodo match \`e un $\lambda$-termine funzione co-ricorsiva. In questo caso il nodo match continuer\`a ad esistere ma verr\`a sostituito il suo nodo body da una serie di nodi applicazione costruiti come segue. L'applicazione foglia Ab avr\`a come figlio destro il termine b ossia il corpo della funzione e come figlio sinistro il nodo s1 primo termine in input alla funzione. L'applicazione al livello successivo avr\`a come figlio sinistro l'applicazione Ab e come figlio destro il nodo $s_2$, secondo termine in input alla funzione. La costruzione continua in modo iterativo fino all'applicazione che avr\`a come figlio destro il nodo sn, n-esimo termine in input alla funzione. Quest'ultimo nodo applicazione sar\`a il nodo che sostituir\`a il body del match.\newline

Formalmente: $\match\> i\> t_0\> (g^{(n)} [s_1, ..., s_n])\> \Vec{t_{i}}\> \rightarrow_{J\delta c} \>Match\> i\> t_0\> (b\> s_1, ..., s_n)\> \Vec{t_{i}}$\newline
\newline

J$\delta$i-riduzione

La J$\delta$i-riduzione \`e applicabile quando si valuta un $\lambda$-termine rappresentante una funzione ricorsiva che ha come n-esimo termine in input un costruttore j-esimo. Dopo aver applicato la J$\delta$i il nodo rappresentante la funzione verr\`a sostituito da una serie di applicazioni costruite come segue. L'applicazione foglia Ab avr\`a come figlio destro il termine b ossia il corpo della funzione e come figlio sinistro il nodo t1 primo termine in input alla funzione. L'applicazione al livello immediatamente dopo avr\`a come figlio sinistro l'applicazione Ab e come figlio destro il nodo t2 secondo termine in input alla funzione. La costruzione continua in modo iterativo fino all'applicazione che avr\`a come figlio destro il nodo tn n-esimo termine in input alla funzione ovvero il nodo costruttore j-esimo. Quest'ultimo nodo applicazione sar\`a il nodo che sostituir\`a il nodo funzione.\newline
Formalmente: $f^{(n)}\> [t_1, ..., t_{n-1}, k_j [s_1, ..., s_m]])\> \rightarrow_{J\delta i} \>b\>t_1, ..., t_{n-1}, k_j [s_1, ..., s_m] $\newline

$\zeta$-riduzione

La $\zeta$-riduzione \`e applicabile quando si valuta un $\lambda$-termine let. Dopo aver applicato la $\zeta$ il nodo let verr\`a sostituito da un nuovo nodo formato dal $\lambda$-termine t3 ossia il corpo del nodo let, il quale sar\`a collegato alla variabile legata al let (il binder). In seguito verr\`a settato come figlio del binder il nodo t2 ovvero il valore della variabile dichiarata nel let.\newline
Formalmente: $Let\> x:t_1 := t_2\> in\> t_3 \rightarrow_\zeta t_3\> [t_2/x]$\newline

$\delta$-riduzione

La $\delta$-riduzione \`e applicabile quando si valuta un $\lambda$-termine rappresentante una costante definita in libreria. Dopo aver applicato la $\delta$ il nodo costante verr\`a sostituito da un nuovo nodo variabile valorizzato dal contenuto della costante.\newline
Formalmente: $c \rightarrow_\delta\> b$\newline


L'applicazione di una delle riduzioni appena presentate richiede ulteriori operazioni sulla struttura del grafo. Ovvero quando inseriamo un nuovo nodo, oltre a rifattorizzare il nodo in esame, dobbiamo aggiornare i padri dei nuovi nodi con quelli della precedente struttura e rivalutare gli stessi. La procedura di rivalutazione \`e necessaria poich\'e potrebbe accadere che l'applicazione di una riduzione crei l'ambiente adatto all'applicazione di un'altra. Ci\`o crea una forma di loop che viene risolta nel momento in cui una nuova valutazione non apporta modifiche alla struttura.\newline



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Grafo Aciclico Diretto}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}

Un grafo aciclico diretto (Directed Acyclic Graph - DAG) \`e un grafo diretto o digrafo che non presenta cicli diretti, ovvero eseguendo una visita in profondit\'a nel grafo non riscontriamo mai archi all'indietro. \newline

In questo lavoro si \`e deciso di utilizzare tale struttura per rappresntare le $\lambda$-espressioni, proprio come suggerito da Paterson e Wegman nell'algoritmo per l'unificazione del primo ordine \cite{K3}. Tale algoritmo non si poneva il problema dei cicli indotti dai binders legati ad un $\lambda$-termine perch\'e non computa l'equivalenza-$\alpha$ sino alle variabili legate, mentre in codesta implementazione la valutazione dei $\lambda$-termini viene estesa anche alle variabili legate ossia i binders.\newline
L'affermazione precedente induce la struttura ad abbandonare la forma di un DAG e ad avvicinarsi a quella di un automa a stati finiti deterministico, ma in realt\'a il ciclo indotto dai binders non \`e veramente tale perch\'e il termine puntato dal binder non \`e un sottotermine ma semplicemente un ambiente a cui \`e appunto legato il binder. Tecnicamente tale arco \`e una rappresentazione grafica dell'ambiente e quindi pu\'o essere visto come il dominio a cui appartiene il binder. Inoltre durante la visita profonda del DAG viene valutata prima la variabile legata e poi l'ambiente ovviando il problema della struttura ciclica.

Per rappresentare una $\lambda$-espressione sotto forma di DAG abbiamo bisogno di codificare sotto forma di nodi i vari costrutti presentati nel \textit{Capitolo 1 Introduzione}.\newline

Le variabili libere da contesto sono rappresentate con un singolo nodo variabile e non hanno figli. Tale rappresentazione vale anche per le sorte, i tipi induttivi, le costanti definite in libreria e le costanti non definite in libreria. Rappresentato in Figura 3.1.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0) (13,3);
\draw (6.5,1) ellipse (1.5 and 1);
\node (A) at (6.5,1) {$Var$};
\draw (6.5,2.5) -- ++(0,0.5);
\draw (6.5,2) -- (6.75,2.5);
\draw (6.5,2) -- (6.25,2.5);
\draw (6.25,2.5) -- (6.75,2.5);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo variabile}\label{fig:prima}
\end{center}
\end{figure}


Le variabili legate ad un ambiente sono rappresentate con un singolo nodo e hanno un arco all'indietro che punta all'ambiente a cui appartengono. Codesta implementazione vale anche per le piai. Rappresentato in Figura 3.2.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0) (13,5);
\draw (6.5,4) ellipse (1.5 and 1);
\node (A) at (6.5,4) {$Ambiente$};
\draw (6.8,2.5) -- ++(0,0.5);
\draw (6.8,2) -- (7.05,2.5);
\draw (6.8,2) -- (6.55,2.5);
\draw (6.55,2.5) -- (7.05,2.5);
\draw (6.5,1) ellipse (1.5 and 1);
\node (B) at (6.5,1) {$Binder$};
\draw (6.2,2) -- ++(0,0.5);
\draw (5.95,2.5) -- (6.2,3);
\draw (6.45,2.5) -- (6.2,3);
\draw (5.95,2.5) -- (6.45,2.5);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo Binder}\label{fig:prima}
\end{center}
\end{figure}

Le applicazioni rappresentano un'operazione binaria e sono rappresentate da un nodo applicazione contenente due figli uno destro e uno sinistro. I figli rappresentano gli operandi dell'operazione. Rappresentato in Figura 3.3.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0)  (13,6);
\draw (6.5,5) ellipse (1.5 and 1);
\node (A) at (6.5,5) {$App$};
\draw (4,1) ellipse (1.5 and 1);
\node (B) at (4,1) {$Figlio Sinistro$};
\draw (6.2,4) -- (4,2.5);
\draw (4,2) -- (4.25,2.5);
\draw (4,2) -- (3.75,2.5);
\draw (3.75,2.5) -- (4.25,2.5);
\draw (9,1) ellipse (1.5 and 1);
\node (C) at (9,1) {$Figlio Destro$};
\draw (6.8,4) -- (9,2.5);
\draw (9,2) -- (9.25,2.5);
\draw (9,2) -- (8.75,2.5);
\draw (8.75,2.5) -- (9.25,2.5);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo applicazione}\label{fig:prima}
\end{center}
\end{figure}

Le $\lambda$-astrazioni sono rappresentate da un nodo $\lambda$ contenente due figli ossia il corpo della $\lambda$-astrazione e la variabile legata all'ambiente. Tale variabile \`e una variabile locale visibile solo nell'ambiente della $\lambda$-astrazione mentre il corpo dell'astrazione potr\'a utilizzare anche le variabili globali. Rappresentato in Figura 3.4.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0) (13,6);
\draw (6.5,5) ellipse (1.5 and 1);
\node (A) at (6.5,5) {$\lambda$};
\draw (4,1) ellipse (1.5 and 1);
\node (B) at (4,1) {$Binder$};
\draw (6.2,4) -- (4.2,2.5);
\draw (4.2,2) -- (4.45,2.5);
\draw (4.2,2) -- (3.95,2.5);
\draw (3.95,2.5) -- (4.45,2.5);
\draw (3.75,2) -- (3.75,5);
\draw (4.5,5) -- (3.75,5);
\draw (4.5,5.25) -- (4.5,4.75);
\draw (5,5) -- (4.5,4.75);
\draw (4.5,5.25) -- (5,5);
\draw (9,1) ellipse (1.5 and 1);
\node (C) at (9,1) {$Body$};
\draw (6.8,4) -- (9,2.5);
\draw (9,2) -- (9.25,2.5);
\draw (9,2) -- (8.75,2.5);
\draw (8.75,2.5) -- (9.25,2.5);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo $\lambda$}\label{fig:prima}
\end{center}
\end{figure}

I costruttori j-esimo con n argomenti vengono rappresentati da un nodo costruttore con \textit{j}+1 figli dove il primo \`e un intero \textit{j} che indica la lunghezza del costruttore e i restatnti figli sono i \textit{j} argomenti del costruttore. Rappresentato in Figura 3.5.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0) (13,6);
\draw (6.5,5) ellipse (1.5 and 1);
\node (A) at (6.5,5) {$K$};
\draw (2,1) ellipse (1.5 and 1);
\node (B) at (2,1) {$J$};
\draw (6.2,4) -- (2,2.5);
\draw (2,2) -- (2.25,2.5);
\draw (2,2) -- (1.75,2.5);
\draw (1.75,2.5) -- (2.25,2.5);
\draw (7,1) ellipse (1.5 and 1);
\node (C) at (7,1) {$s1$};
\draw (6.8,4) -- (7,2.5);
\draw (7,2) -- (7.25,2.5);
\draw (7,2) -- (6.75,2.5);
\draw (6.75,2.5) -- (7.25,2.5);
\draw (11,1) ellipse (1.5 and 1);
\node (D) at (11,1) {$sk$};
\draw (7,4.05) -- (11,2.5);
\draw (11,2) -- (11.25,2.5);
\draw (11,2) -- (10.75,2.5);
\draw (10.75,2.5) -- (11.25,2.5);

\draw (7.8,2.25) -- (8.2,2.25);
\draw (8.8,2.25) -- (9.2,2.25);
\draw (9.8,2.25) -- (10.2,2.25);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo costruttore j-esimo}\label{fig:prima}
\end{center}
\end{figure}

Il costrutto Match \`e rappresentato tramite un nodo match con \textit{i}+1 figli. Il primo rappresenta il corpo su cui fare match mentre i restanti \textit{i} figli rappresentano i vari rami del match ovvero i nodi da eseguire dopo aver messo a confronto i vari casi. Rappresentato in Figura 3.6.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0) (13,6);
\draw (6.5,5) ellipse (1.5 and 1);
\node (A) at (6.5,5) {$Match$};
\draw (2,1) ellipse (1.5 and 1);
\node (B) at (2,1) {$Body$};
\draw (6.2,4) -- (2,2.5);
\draw (2,2) -- (2.25,2.5);
\draw (2,2) -- (1.75,2.5);
\draw (1.75,2.5) -- (2.25,2.5);
\draw (7,1) ellipse (1.5 and 1);
\node (C) at (7,1) {$t1$};
\draw (6.8,4) -- (7,2.5);
\draw (7,2) -- (7.25,2.5);
\draw (7,2) -- (6.75,2.5);
\draw (6.75,2.5) -- (7.25,2.5);
\draw (11,1) ellipse (1.5 and 1);
\node (D) at (11,1) {$tn$};
\draw (7,4.05) -- (11,2.5);
\draw (11,2) -- (11.25,2.5);
\draw (11,2) -- (10.75,2.5);
\draw (10.75,2.5) -- (11.25,2.5);

\draw (7.8,2.25) -- (8.2,2.25);
\draw (8.8,2.25) -- (9.2,2.25);
\draw (9.8,2.25) -- (10.2,2.25);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo match}\label{fig:prima}
\end{center}
\end{figure}

Il costrutto Let \`e utilizzato per dichiarare variabili locali o abbreviaviazioni ed \`e rappresentato tramite un nodo let con tre figli. Il primo \`e una variabile \textit{t} legata all'ambiente, il secondo \`e il corpo del let e il terzo \`e il valore della variabile dichiarata. Rappresentato in Figura 3.7.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0) (13,6);
\draw (6.5,5) ellipse (1.5 and 1);
\node (A) at (6.5,5) {$Let$};
\draw (2,1) ellipse (1.5 and 1);
\node (B) at (2,1) {$x$};
\draw (6.2,4) -- (2.2,2.5);
\draw (2.2,2) -- (2.45,2.5);
\draw (2.2,2) -- (1.95,2.5);
\draw (1.95,2.5) -- (2.45,2.5);
\draw (1.75,2) -- (1.75,5);

\draw (4.5,5) -- (1.75,5);
\draw (4.5,5.25) -- (4.5,4.75);
\draw (5,5) -- (4.5,4.75);
\draw (4.5,5.25) -- (5,5);

\draw (5.5,1) -- (4,1);
\draw (4,1.25) -- (4,0.75);
\draw (3.5,1) -- (4,0.75);
\draw (4,1.25) -- (3.5,1);

\draw (7,1) ellipse (1.5 and 1);
\node (C) at (7,1) {$Body$};
\draw (6.8,4) -- (7,2.5);
\draw (7,2) -- (7.25,2.5);
\draw (7,2) -- (6.75,2.5);
\draw (6.75,2.5) -- (7.25,2.5);
\draw (11,1) ellipse (1.5 and 1);
\node (D) at (11,1) {$t$};
\draw (7,4.05) -- (11,2.5);
\draw (11,2) -- (11.25,2.5);
\draw (11,2) -- (10.75,2.5);
\draw (10.75,2.5) -- (11.25,2.5);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo let}\label{fig:prima}
\end{center}
\end{figure}

Le funzioni ricorsive sono rappresntate da un nodo funzione con \textit{i}+1 figli. Il primo \`e un intero pari ad \textit{i} che indica il numero di argomenti in input alla funzione, mentre i restanti \textit{i} figli sono esattamente gli \textit{i} input. La medesima rappresentazione la ritroviamo anche nelle funzioni co-ricorsive. Rappresentato in Figura 3.8.\newline

\begin{figure}[h]
\begin{tikzpicture}
\draw [help lines] (0,0) (13,6);
\draw (6.5,5) ellipse (2 and 1);
\node (A) at (6.5,5) {$FRic / G-coRic$};
\draw (1.5,1) ellipse (1.5 and 1);
\node (B) at (1.5,1) {$Body$};
\draw (5,4.3) -- (1.5,2.5);
\draw (1.5,2) -- (1.75,2.5);
\draw (1.5,2) -- (1.25,2.5);
\draw (1.25,2.5) -- (1.75,2.5);

\draw (4.5,2) ellipse (1.5 and 1);
\node (C) at (4.5,2) {$n$};
\draw (6.2,4) -- (4.5,3.5);
\draw (4.5,3) -- (4.75,3.5);
\draw (4.5,3) -- (4.25,3.5);
\draw (4.25,3.5) -- (4.75,3.5);

\draw (7.5,1) ellipse (1.5 and 1);
\node (D) at (7.5,1) {$t1$};
\draw (7,4) -- (7.5,2.5);
\draw (7.5,2) -- (7.75,2.5);
\draw (7.5,2) -- (7.25,2.5);
\draw (7.25,2.5) -- (7.75,2.5);

\draw (11.5,1) ellipse (1.5 and 1);
\node (E) at (11.5,1) {$tn$};
\draw (7.2,4.05) -- (11.5,2.5);
\draw (11.5,2) -- (11.75,2.5);
\draw (11.5,2) -- (11.25,2.5);
\draw (11.25,2.5) -- (11.75,2.5);

\draw (8.3,2.25) -- (8.7,2.25);
\draw (9.3,2.25) -- (9.7,2.25);
\draw (10.3,2.25) -- (10.7,2.25);
\end{tikzpicture}
\begin{center}
\caption[]{Esempio nodo funzione ricorsiva/co-ricorsiva}\label{fig:prima}
\end{center}
\end{figure}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Algoritmo - AlphaLinearConversion - SISTEMARE}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
L'algoritmo implementato consiste in una serie di procedure che consento la visita esaustiva di un grafo aciclico diretto permettendo la valutazione e la comparazione dei termini presenti nei nodi del grafo.\newline
L'input dell'algoritmo \`e un array contenente tutti i nodi del grafo. Questi possono anche essere ordinati in modo casuale poich\'e sar\`a l'algoritmo stesso a risalire dai nodi figli verso i padri e viceversa durante la valutazione. 
L'output dell'algoritmo \`e banale. Se il programma termina vuol dire che le 2 $\lambda$-espressioni sono bi-simili ossia hanno strutture diverse ma possono essere collassate nello stesso $\lambda$-termine. Mentre se avviene un uscita anomala corrisponde a dimostrare che le 2 $\lambda$-espressioni rappresentano due espressioni realmente diverse e quindi non sono bi-simili.\newline

\section{Strutture Dati}
L'algoritmo lavora su nodi appartenenti ad un grafo ma, non essendo necessaria, non esiste una vera e propria struttura dati che rappresenti il grafo. Per strutturare le $\lambda$-espressioni sotto forma di DAG vengono creati una serie di nodi collegati fra loro, generando dietro le quinte la struttura del grafo.

I nodi vengono rappresentati tramite un ADT in C ovvero tramite una variabile union, che contiene tutte le forme possibili del nodo, legata ad una label che distingue le varie tipologie di nodo possibili. La struct che definisce il nodo viene arricchita da ulteriori informazioni necessarie alla valutazione del nodo stesso e alla visita del grafo. Di seguito \`e riportata la struct in questione.

\begin{verbatim}
struct Node {
    enum TypeNode label;
    union {
        struct NodeFVar fvar;
        struct NodeBVar bvar;
        struct NodePiai piai;
        struct NodeShared shared;
        struct NodeApp app;
        struct NodeLam lam;
        struct NodeMatch match;
        struct NodeFRic fRic;
        struct NodeGCoRic gCoRic;
        struct NodeLet let;
        struct NodeJthConstr jCostr;
        struct NodeConst constant;
    } content;
    Node *canonic;
    Node *copy;
    Bool building;
    List *parentNodes;
    List *neighbour;
    List *queue;
    Bool root;
    Bool reachable;
    Bool visited;
    int rc;
};
enum TypeNode {
    FVar, BVar, Piai, Shared, App, Lam, Match, 
    Let, FRic, GCoRic, Constructor, Constant
};
\end{verbatim}


Il content del Nodo \`e rappresentato da un costrutto chiamato union che permette di raggruppare in un unico tipo un insieme di tipi. La rappresentazione in memoria di un tipo union sar\`a sempre la stessa in tutti i casi ossia occuper\`a l'area di memoria massima fra tutti i tipi che rappresenta. Una volta popolato il content non sar\`a pi\`u possibile risalire al tipo del dato contenuto, se non tramite una label opportunamente valorizzata, proprio perch\'e non possono essere confrontati i puntatori essendo uniformi.

Come possiamo notare la label che differenzia il content del Nodo \`e un tipo enumerato. Ci\`o permette di essere pi\`u efficienti durante i vari switch...case utilizzati nelle procedure perch\'e la label viene vista come un intero e la comparazione fra due interi \`e pi\`u veloce della comparazione fra aree di memoria o fra stringhe. Inoltre utilizzando i tipi enumerati anzich\'e dei semplici interi preserviamo la legibilit\`a del codice facilitando future operazioni di manutenzione o espanzione del progetto.

La struct ListHT *parentNodes \`e una puntatore alla testa della lista dei genitori di un nodo e serve appunto per creare la stuttura del DAG e per risalire al nodo root del grafo durante la valutazione. Il nodo root avr\`a tale lista vuota mentre i restanti nodi dovranno avere almeno un genitore prima che inizi la valutazione. Il contenuto della lista in questione potr\`a solo crescere e in alcuni casi subire refactoring durante le procedure di riduzione.

La struct ListHT *neighbour \`e anch'essa un puntatore alla testa di una lista. Tale lista \`e utilizzata per creare i collegamenti fra i nodi dei due DAG e tali relazioni vengono definite $\sim$neighbour. Nel momento in cui viene scandita la lista si avviano procedure di comparazione che determinano se due nodi sono bi-simili o meno. \newline
Inizialmente solo il nodo root di ogni DAG sar\`a collegato da una relazione di $\sim$neighbour, mentre i restanti nodi popoleranno tale lista durante la valutazione.

I rimanenti campi della struct Nodo sono utilizzati esclusivamente per valutare e confrontare i nodi nell'algoritmo e possono essere considerate delle variabili di appoggio per semplificare il codice. Inialmente sono settate su un valore di default come NULL o False.

La struct Node *canonic serve per settare il canonico di un nodo durante la valutazione per poi confrontare il canonico di due nodi in alcune casistiche della fase di comparazione.

La enum Bool building \`e un tipo enumerato che pu\`o assumere il valore True o False. \`E sempre settata su False tranne quando il nodo \`e in fase di analisi.
La variabile in questione \`e utilizzata come un assert poich\'e se stiamo analizzando i parent di un nodo che hanno gi\'a il nodo canonico definito se tale nodo \`e in fase di analisi, ovvero ha building settato a true,  l'algoritmo effettua un exit perch\'e vuol dire che abbiamo delle forme cicliche nel grafo, cosa che non dovrebbe accadere.

La struct Node *copy \`e utilizzata per salvare una copia del nodo prima di richiamare delle procedure di riduzione.

La struct ListHT *queue \`e una lista dove vengono salvati i nodi da comparare con il nodo attualmente in analisi.\newline


Le forme che pu\`o assumere il content di un Nodo sono molteplici e corrispondono ai costrutti elencati nel \textit{Capitolo 1 Introduzione}. Alcuni costrutti vengono collassati nella stessa struttura poich\'e seguono le medesime regole e quindi sarebbe stato inutile differenziare le casistiche. 

La struct NodeFVar contiene un singolo campo e rappresenta le variabili libere da contesto, le sorte, i tipi induttivi e le costanti non definite in libreria. Di seguito \`e riportata la relativa struttura.

\begin{verbatim}
struct NodeFVar {
    int var;//dummy
};
\end{verbatim}

La struct NodeBVar contiene il campo binder e rappresenta le variabili legate e le piai (tipo delle funzioni). Di seguito \`e riportata la relativa struttura.

\begin{verbatim}
struct NodeBVar {
    Node *binder;
};
\end{verbatim}

La struct NodePiai CONTINUARE........

\begin{verbatim}
struct NodePiai {
    Node *var;
    Node *body;
};
\end{verbatim}

La struct NodeApp contiene i due figli di un'applicazione e appunto \`e utilizzata per rappresentare le operazioni binarie. Di seguito \`e riportata la relativa struttura.

\begin{verbatim}
struct NodeApp {
    Node *left;
    Node *right;
};
\end{verbatim}

La struct NodeLam \`e utilizzata per rappresentare le $\lambda$-astrazioni e contiene due variabili, ovvero il corpo della $\lambda$-astrazione e la variabile legata all'ambiente la quale dovra essere necessariamente di tipo NodeBVar. Di seguito \`e riportata la relativa struttura.

\begin{verbatim}
struct NodeLam {
    Node *var;//NodeBVar
    Node *body;
};
\end{verbatim}

La struct NodeJthConstr rappresenta i costruttori j-esimo con n argomenti e contiene due campi un intero j e una lista di argomenti. Di seguito \`e riportata la relativa struttura.

\begin{verbatim}
struct NodeJthConstr {
    int j;
    List *arg;
    int n;
};
\end{verbatim}

La struct NodeConst rappresenta le costanti definite in libreria e contiene un singolo campo rappresentante il valore della costante. Di seguito \`e riportata la relativa struttura. 

\begin{verbatim}
struct NodeConst {
    Node *var;
};
\end{verbatim}

La struct NodeMatch rappresenta il costrutto match e contiene un body e la lista dei vari casi del match. Di seguito \`e riportata la relativa struttura.

\begin{verbatim}
struct NodeMatch {
    Node *body;
    List *branches;
    int n;
};
\end{verbatim}

La struct NodeLet rappresenta il costrutto let e contiene tre campi ossia il binder legato all'ambiente che sar\`a di tipo NodeBVar, il valore t2 della variabile dichiarata e il corpo t3 dove utilizzo la variabile dichiarata. Di seguito \`e riportata la relativa struttura.

\begin{verbatim}
struct NodeLet {
    Node *var;//NodeBVar
    Node *t2;
    Node *t3;
};
\end{verbatim}

La struct NodeFRic rappresenta le funzioni ricorsive mentre la struct NodeGCoRic rappresenta le funzioni co-ricorsive. Entrambe contengono un binder legato all'ambiente di tipo NodeBVar, il corpo della funzione, un intero che indica il numero di argomenti in input e la lista di tali argomenti. Di seguito sono riportate le relative strutture.

\begin{verbatim}
struct NodeFRic {
    Node *var;//NodeBVar
    Node *t;
    int n;
    List *arg;
};
struct NodeGCoRic {
    Node *var;//NodeBVar
    Node *t;
    int n;
    List *arg;
};
\end{verbatim}

La struct ListHT presente nelle strutture sovracitate rappresenta una lista di elementi di tipo ListElement. Al suo interno contiene un puntatore alla testa della lista e un contatore utili per iterarare sulla lista e un puntatore alla coda necessario per appendere nuovi elementi. Ogni elemento conterr\`a un puntatore ad un Nodo e un puntatore al successivo elemento della lista.\newline
Si \`e deciso di implemetare tale struttura, anzich\'e utilizzare strutture di libreria, per preservare la complessit\`a desiderata e quindi essere pi\`u efficienti nelle operazioni in cui \`e coinvoilta. Di seguito sono riportate le relative strutture.
\begin{verbatim}
struct ListItem {
    Node *node;
    ListItem *next;
};
struct List {
    ListItem *head;
    ListItem *tail;
};
\end{verbatim}

\section{Propagazione $\sim$neighbour}
La diffusione dei $\sim$neighbour avviene tramite la funzione Propagate che prende in input due nodi m e c e testa se questi rispettano gli invarianti di propagazione. Se ci\`o avviene l'algoritmo continua a girare e in alcuni casi aggiunge sulla lista dei neighbour dei figli di m i corrispettivi figli del nodo c e viceversa. Mentre se non vengono rispettati gli invarianti avviene un exit e l'algoritmo termina segnalando che le espressioni non sono bi-simili.\newline

Gli invarianti di propagazione variano a seconda del tipo di nodo analizzato. Esistono anche tipologie di nodi che non si propagano mai ovvero quelli di tipo Shared, Let o Constant. Le restanti tipologie di nodo propagano e/o testano la bisimilarit\`a, esse hanno un'invariante comune soddisfatto se m e c sono dello stesso tipo.\newline
Un nodo di tipo FVar o BVar non propaga mai i suoi figli ma verifica un'ulteriore invariante ovvero che il canonico della variabile contenuta in m deve essere uguale al canonico della variabile contenuta in c.\newline
Un nodo di tipo App propaga i rispettivi figli destro e sinistro di m con quelli di c.\newline
Un nodo di tipo Lam o Match propaga unicamente i rispettivi body di m e c.\newline
Un nodo di tipo FRic o GCoRic verifica un invariante aggiuntivo ossia che il numero di argomenti in input deve essere uguale. Se ci\`o avviene propaga il corpo della funzione e l'intera lista di argomenti. \newline
Un nodo di tipo Constructor verifica che i due nodi abbiano lo stesso numero di argomenti e se ci\`o avviene propaga l'intera lista di argomenti fra i due nodi.\newline

Le procedure di propagazione descritte vengono utilizzate per popolare la lista dei $\sim$neighbour dei nodi analizzati, la quale verr\`a visitata nella procedura BuildClass descritta nel paragrafo successivo 4.3 Valutazione e riduzione. 

\section{Valutazione e Riduzione}
Il processo di valutazione e riduzione avviene in 2 fasi. Inanzitutto viene invocata la funzione WeakCbVEval sul nodo root di entrambi i DAG e successivamente viene invocata la funzione DAGCheckAndEval fornendo come input l'array contenente tutti i nodi dei due DAG.\newline
La procedura DAGCheckAndEval visita l'array in input e solo se un nodo non \`e stato ancora valutato, ossia se non ha il nodo canonico definito, richiama la procedura BuildClass che si occupa della sua valutazione.

\subsection{BuildClass}
La funzione BuildClass si occupa della valutazione di un nodo c ricevuto in input. Inizialmente setta lo stato di alcune variabili di processo del nodo c e successivamente avvia un ciclo while nel quale scorre la queue di tale nodo. La queue inizialmente conterr\`a unicamente un puntatore al nodo in analisi ma durante tale ciclo verr\`a popolata da ulteriori nodi. La funzione terminer\`a quando la queue sar\`a esaurita eseguendo un'operazione di coda che setta lo stato building di c su False.\newline

Durante ogni passo del ciclo while viene estratto un nodo n dalla queue e vengono eseguiti ulteriori cicli sui genitori e sui $\sim$neighbour di n.\newline
Durante la visita dei genitori, salvati nella lista parentNodes, se il genitore analizzato non \`e stato ancora valutato viene richiamata ricorsivamente la funzione BuildClass sul genitore, mentre se \`e gi\`a stato valutato viene testato un'invariante che potrebbe provocare un exit dell'algoritmo. Tale invariante verifica che la variabile building del canonico del genitore sia settata su False, se ci\`o non si verifica l'algoritmo termina.\newline
Terminata la visita dei genitori se n non ha $\sim$neighbour la funzione termina normalmente settando lo stato building su False ed effettuando un return al chiamante. Prima di terminare vengono testati due invarianti ossia che la queue sia stata esaurita e che l'ultimo nodo estratto dalla queue sia proprio c. Quindi se uno dei due invarianti non viene rispettato, quando n non ha $\sim$neighbour, avviene un exit segnalando la non bi-similarit\`a.\newline
Se n ha $\sim$neighbour avviene la visita della relativa lista. Durante tale ciclo si estrae un $\sim$neighbour dalla lista e si verifica se il suo canonico \`e definito. Se non \`e definito si aggiunge il $\sim$neighbour analizzato nella queue di c e si setta il suo canonico su c, mentre se \`e definito ed \`e diverso da c avviene un exit segnalando la non bi-similarit\`a dei due DAG.\newline
Di seguito se n rappresenta un nodo $\lambda$-astrazione viene effettuato un refactoring del suo body con l'output della funzione WeakCbVEval richiamata sul body di n.\newline
Infine, prima di passare all'iterata successiva, viene invocata la funzione Propagate con input n e c.\newline

La funzione BuildClass non produce alcun output ma, come descritto precedentemente, pu\`o provocare la terminazione dell'algoritmo e pu\`o modificare direttamente i figli dei nodi che analizza.

\subsection{WeakCbVEval}
La funzione WeakCbVEval si occupa della riduzione dei $\lambda$-termini rappresentati nei nodi dei DAG. Essa riceve in input un nodo n e ritorna al chiamante o n stesso o un nodo ridotto, nel caso in cui \`e possibile applicare delle regole di riduzione sull'input.\newline
I casi in cui ritorna n stesso sono quelli in cui il tipo del nodo in input \`e FVar, BVar, Lam, GCoRic o Constructor, ma anche in alcune casistiche per nodi di tipo Match e FRic che vedremo pi\`u avanti in codesta sezione.\newline

Se n \`e di tipo Shared o Constant semplicemente viene eliminato il doppio puntatore tornando il corpo di n, nel primo caso il nodo sherato mentre nel secondo la variabile rappresentante il valore della costante.\newline

Se n rappresenta un nodo applicazione prima richiamo ricorsivamente la funzione WeakCbVEval sul figlio destro e sinistro di n calcolando due nuovi nodi n2 e n1.\newline
Di seguito se n1 \`e un nodo $\lambda$-astrazione posso applicare la $\beta$-riduzione e quindi chiamare la funzione Inst fornendo come input il body di n1, il nodo n1 e un nuovo nodo Shared con body n2. In questo caso l'output della funzione al top level sar\`a l'output della chiamata ricorsiva di WeakCbVEval con input l'output della chiamata alla funzione Inst. \newline
Mentre se n1 non \`e un nodo $\lambda$-astrazione l'output sar\`a un nuovo nodo applicazione con figlio sinistro n1 e destro n2.\newline

Quando n rappresenta un nodo Match si presentano tre casistiche differenti condizionate dal tipo del body del match. \newline
Se il body \`e un costruttore j-esimo prima si prova a ridurre il ramo j-esimo effettuando una chiamata ricorsiva a WeakCbVEval e salvando l'output in n1. Di seguito si calcola la sequenza di applicazioni, come descritto nel \textit{Capitolo 2 Regole di riduzione}, per applicare la J-riduzione salvando il nodo root della sequenza nel nodo n2. Infine l'output sar\`a il nodo restituito dalla chiamata ricorsiva di WeakCbVEval sul nodo n2.\newline
Mentre se il body rappresenta una funzione co-ricorsiva verr\`a applicata la J$\delta$c-riduzione mantenendo il nodo match ma creando la sequenza di applicazioni sul body del match. L'output sar\`a la chiamata ricorsiva di WeakCbVEval su n stesso ma con body modificato.\newline
Quando il body del match non ricade in uno dei due casi precedenti l'output sar\`a il nodo n fornito in input.\newline

Se n \`e di tipo Let verr\`a applicata la $\zeta$-riduzione ritornando come output la chiamata ricorsiva della funzione WeakCbVEval con input t3. Prima di effettuare tale chiamata modificheremo il binder puntato dalla bvar del nodo Let con il figlio t2 dello stesso.\newline

Se n rappresenta una funzione ricorsiva per prima cosa si prover\`a a ridurre l'argomento j-esimo tramite WeakCbVEval. Di seguito se tale argomento \`e un costruttore j-esimo potr\`a essere applicata la J$\delta$i-riduzione calcolando la sequenza di applicazioni, come descritto nel \textit{Capitolo 2 Regole di riduzione}. In questo caso l'output sar\`a la chiamata ricorsiva di WeakCbVEval sul nodo root della sequenza di applicazioni, altrimenti l'output sar\`a n stesso dopo aver richiamato sul body t di n la funzione WeakCbVEval.  \newline

\newline.\newline .\newline
Trovare conclusione capitolo
\newline.\newline .\newline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Test e Risultati}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
Esporre fase di debug con il tool graphviz???


Test e Risultati TESTO\newline
Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline Test e Risultati TESTO\newline 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Conclusioni}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}

Conclusioni TESTO



\clearpage{\pagestyle{empty}\cleardoublepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\renewcommand{\chaptermark}[1]{\markright{\thechapter \ #1}{}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\appendix                               %imposta le appendici
\chapter{Listato dei programmi}               %crea l'appendice

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries \thechapter \:Listato dei programmi - SISTEMARE SPAZIATURA}]
{\fancyplain{}{\bfseries\thepage}}

\section{DAGCheckAndEval}
\begin{verbatim}
typedef struct Node Node;
typedef struct List List;
typedef struct ListItem ListItem;
typedef enum Bool Bool;
List *nodesHT;//Node List

void DAGCheckAndEval(List *nodesHT, Node *root1, Node *root2) {
    root1->root = True;
    root2->root = True;
    PushNeighbour(root1, root2);
    ListItem *nodes = nodesHT->head;
    while (nodes->node != NULL) {
        if (nodes->node->canonic == NULL)
            BuildClass(nodes->node);
        nodes = nodes->next;
    }
}
\end{verbatim}
\section{BuildClass}
\begin{verbatim}
void BuildClass(Node *c) {
    c->building = True;
    c->queue = InitListHT();
    ListItem *iterQueue = c->queue->head;
    Enqueue(c, c);
    while (iterQueue->node != NULL) {
        Node *n = iterQueue->node;
        SearchIfReachable(n);
        if (n->reachable == False) {
            assert(n->neighbour->head->node == NULL);
            c->building = False;
            return;
        }
        // visit parents
        assert(n->parentNodes != NULL);
        ListItem *iterParents = n->parentNodes->head;
        while (iterParents->node != NULL) {
            if (iterParents->node->canonic == NULL)
                BuildClass(iterParents->node);
            else if (iterParents->node->canonic->building == True)
                PrintExit(2);
            iterParents = iterParents->next;
        }
        // visit neighbours
        assert(n->neighbour != NULL);
        ListItem *iterNeighbour = n->neighbour->head;
        while (iterNeighbour->node != NULL) {
            Enqueue(iterNeighbour->node, c);
            iterNeighbour = iterNeighbour->next;
        }

        if (n != c)
            Propagate(n, c);
        iterQueue = iterQueue->next;
    }
    c->building = False;
}

void Enqueue(Node *n, Node *c) {
    if (n->canonic == NULL) {
        PushToListHT(c->queue, n);
        n->canonic = c;
    } else if (n->canonic != c)
        PrintExit(2);
}

void SearchIfReachable(Node *n) {
    n->reachable = n->root;
    // visit parents
    assert(n->parentNodes != NULL);
    ListItem *m = n->parentNodes->head;
    while (m->node != NULL && n->reachable != True) {
        if (m->node->visited == False)
            SearchIfReachable(m->node);
        n->reachable = m->node->reachable;
        m = m->next;
    }
    n->visited = True;
}
\end{verbatim}
\section{Propagate}
\begin{verbatim}
void Propagate(Node *m, Node *c) {
    switch (m->label) {
        case FVar:
            if (m != c)
                PrintExit(3);
            break;
        case BVar:
            if (c->label == BVar) {
                assert(m->content.bvar.binder != NULL);
                assert(c->content.bvar.binder != NULL);
                if (m->content.bvar.binder->canonic != c->content.bvar.binder->canonic)
                    PrintExit(3);
            } else
                PrintExit(3);
            break;
        case Piai:
            if (c->label == Piai)
                PushNeighbour(m->content.piai.body, c->content.piai.body);
            else
                PrintExit(3);
            break;
        case Shared:
            assert(0);
        case App:
            if (c->label == App) {
                PushNeighbour(m->content.app.left, c->content.app.left);
                PushNeighbour(m->content.app.right, c->content.app.right);
            } else
                PrintExit(3);
            break;
        case Lam:
            if (c->label == Lam)
                PushNeighbour(m->content.lam.body, c->content.lam.body);
            else
                PrintExit(3);
            break;
        case Match:
            if (c->label == Match && m->content.match.n == c->content.match.n) {
                PushNeighbour(m->content.match.body, c->content.match.body);
                ListItem *iter = m->content.match.branches->head;
                ListItem *iter2 = c->content.match.branches->head;
                for (int i = 0; i < m->content.match.n; ++i) {
                    PushNeighbour(iter->node, iter2->node);
                    iter = iter->next;
                    iter2 = iter2->next;
                }
            } else
                PrintExit(3);
            break;
        case Let:
            assert(0);
        case FRic:
            if (c->label == FRic && m->content.fRic.n == c->content.fRic.n) {
                PushNeighbour(m->content.fRic.t, c->content.fRic.t);
                ListItem *iter = m->content.fRic.arg->head;
                ListItem *iter2 = c->content.fRic.arg->head;
                for (int i = 0; i < m->content.fRic.n; ++i) {
                    PushNeighbour(iter->node, iter2->node);
                    iter = iter->next;
                    iter2 = iter2->next;
                }
            } else
                PrintExit(3);
            break;
        case GCoRic:
            if (c->label == GCoRic && m->content.gCoRic.n == c->content.gCoRic.n) {
                PushNeighbour(m->content.gCoRic.t, c->content.gCoRic.t);
                ListItem *iter = m->content.gCoRic.arg->head;
                ListItem *iter2 = c->content.gCoRic.arg->head;
                for (int i = 0; i < m->content.gCoRic.n; ++i) {
                    PushNeighbour(iter->node, iter2->node);
                    iter = iter->next;
                    iter2 = iter2->next;
                }
            } else
                PrintExit(3);
            break;
        case Constructor:
            if (c->label == Constructor && m->content.jCostr.j == c->content.jCostr.j &&
                m->content.jCostr.n == c->content.jCostr.n) {
                ListItem *iter = m->content.jCostr.arg->head;
                ListItem *iter2 = c->content.jCostr.arg->head;
                for (int i = 0; i < m->content.jCostr.n; ++i) {
                    PushNeighbour(iter->node, iter2->node);
                    iter = iter->next;
                    iter2 = iter2->next;
                }
            } else
                PrintExit(3);
            break;
        case Constant:
            assert(0);
    }
}

void PushNeighbour(Node *m, Node *c) {
    Node *m1 = WeakCbVEval(m);
    Node *c1 = WeakCbVEval(c);

    PushToListHT(m1->neighbour, c1);
    PushToListHT(c1->neighbour, m1);
}



\end{verbatim}
\section{WeakCbVEval}
\begin{verbatim}
Node *WeakCbVEval(Node *n) {
    ListItem *listElement;
    Node *n1;
    Node *n2;
    Node *nodeReturn;
    switch (n->label) {
        case FVar:
            return n;
        case BVar:
            return n;
        case Piai:
            return n;
        case Shared:
            nodeReturn = n->content.shared.body;
            RefactoringNode(n, nodeReturn);
            return nodeReturn;
        case App:
            n2 = WeakCbVEval(n->content.app.right);
            n1 = WeakCbVEval(n->content.app.left);
            if (n1->label == Lam) {
                nodeReturn = WeakCbVEval(Inst(n1->content.lam.body, n1, n2));
                RefactoringNode(n, nodeReturn);
                return nodeReturn;
            } else
                return n;
        case Lam:
            return n;
        case Match:
            switch (n->content.match.body->label) {
                case Constructor://j
                    listElement = n->content.match.branches->head;
                    for (int i = 0; i < n->content.match.body->content.jCostr.n - 1; ++i) {
                        listElement = listElement->next;
                    }
                    n2 = AppReplacement(listElement->node, n->content.match.body->content.jCostr.arg);
                    nodeReturn = WeakCbVEval(n2);
                    RefactoringNode(n, nodeReturn);
                    return nodeReturn;
                case GCoRic://jDelta-c
                    n2 = InitGCoRic(n->content.match.body->content.gCoRic.var, n->content.match.body->content.gCoRic.t,
                                    0, InitListHT());
                    n1 = Inst(n->content.match.body->content.gCoRic.t, n->content.match.body->content.gCoRic.var, n2);
                    if (!(n1->label == Shared && n1->content.shared.body == n2))
                        FreeRC(n2);
                    n2 = AppReplacement(n1, n->content.match.body->content.gCoRic.arg);
                    RefactoringNode(n->content.match.body, n2);
                    n->content.match.body = n2;
                    nodeReturn = WeakCbVEval(n);
                    return nodeReturn;
                default:
                    return n;
            }

        case Let:
            n->content.let.var->content.bvar.binder = WeakCbVEval(
                    n->content.let.t2);
            n->content.let.var->content.bvar.binder->rc++;
            nodeReturn = WeakCbVEval(n->content.let.t3);
            RefactoringNode(n, nodeReturn);
            return nodeReturn;
        case FRic:
            listElement = n->content.fRic.arg->head;
            for (int i = 0; i < n->content.fRic.n - 1; ++i) {
                listElement = listElement->next;
            }
            listElement->node = WeakCbVEval(listElement->node);
            if (listElement->node->label == Constructor) {
                n1 = Inst(n->content.fRic.t, n->content.fRic.var, n);//b
                nodeReturn = WeakCbVEval(AppReplacement(n1, n->content.fRic.arg));
                RefactoringNode(n, nodeReturn);
                return nodeReturn;
            } else {
                n->content.fRic.t = WeakCbVEval(n->content.fRic.t);
                return n;
            }
        case GCoRic:
            return n;
        case Constructor:
            return n;
        case Constant:
            nodeReturn = n->content.constant.var;
            RefactoringNode(n, nodeReturn);
            return nodeReturn;
    }
}


\end{verbatim}
\section{RefactoringNode}
\begin{verbatim}
void RefactoringNode(Node *oldNode, Node *newNode) {
    newNode->root = oldNode->root;
    newNode->reachable = oldNode->reachable;

    ListItem *parent = oldNode->parentNodes->head;
    while (parent->node != NULL) {
        UpdateSon(oldNode, newNode, parent->node);
        newNode->rc++;
        PushToListHT(newNode->parentNodes, parent->node);
        parent = parent->next;
    }
    FreeRC(oldNode);
}

void UpdateSon(Node *oldSon, Node *newSon, Node *parent) {
    int find = 0;
    switch (parent->label) {
        case FVar:
            assert(0);
        case BVar:
            if (parent->content.bvar.binder == oldSon)
                parent->content.bvar.binder = newSon;
            else
                assert(0);
            break;
        case Piai:
            if (parent->content.piai.body == oldSon)
                parent->content.piai.body = newSon;
            else if (parent->content.piai.var == oldSon)
                parent->content.piai.var = newSon;
            else
                assert(0);
            break;
        case Shared:
            if (parent->content.shared.body == oldSon)
                parent->content.shared.body = newSon;
            else
                assert(0);
            break;
        case App:
            if (parent->content.app.left == oldSon)
                parent->content.app.left = newSon;
            else if (parent->content.app.right == oldSon)
                parent->content.app.right = newSon;
            else
                assert(0);
            break;
        case Lam:
            if (parent->content.lam.body == oldSon)
                parent->content.lam.body = newSon;
            else if (parent->content.lam.var == oldSon)
                parent->content.lam.var = newSon;
            else
                assert(0);
            break;
        case Match:
            if (parent->content.match.body == oldSon)
                parent->content.match.body = newSon;
            else {
                assert(parent->content.match.branches != NULL);
                ListItem *branches = parent->content.match.branches->head;
                while (find == 0 && branches->node != NULL) {
                    if (branches->node == oldSon) {
                        branches->node = newSon;
                        find = 1;
                    }
                    branches = branches->next;
                }
                if (find == 0)
                    assert(0);
            }
            break;
        case Let:
            if (parent->content.let.t3 == oldSon)
                parent->content.let.t3 = newSon;
            else if (parent->content.let.t2 == oldSon)
                parent->content.let.t2 = newSon;
            else if (parent->content.let.var == oldSon)
                parent->content.let.var = newSon;
            else
                assert(0);
            break;
        case FRic:
            if (parent->content.fRic.t == oldSon)
                parent->content.fRic.t = newSon;
            else if (parent->content.fRic.var == oldSon)
                parent->content.fRic.var = newSon;
            else {
                assert(parent->content.fRic.arg != NULL);
                ListItem *arg = parent->content.fRic.arg->head;
                int i = 0;
                while (find == 0 && arg->node != NULL) {
                    if (arg->node == oldSon) {
                        arg->node = newSon;
                        find = 1;
                    }
                    ++i;
                    arg = arg->next;
                }
                if (find == 0)
                    assert(0);
            }
            break;
        case GCoRic:
            if (parent->content.gCoRic.t == oldSon)
                parent->content.gCoRic.t = newSon;
            else if (parent->content.gCoRic.var == oldSon)
                parent->content.gCoRic.var = newSon;
            else {
                assert(parent->content.gCoRic.arg != NULL);
                ListItem *arg = parent->content.gCoRic.arg->head;
                while (arg->node != NULL) {
                    if (arg->node == oldSon) {
                        arg->node = newSon;
                        find = 1;
                    }
                    arg = arg->next;
                }
                if (find == 0)
                    assert(0);
            }
            break;
        case Constructor:
            assert(parent->content.jCostr.arg != NULL);
            ListItem *arg = parent->content.jCostr.arg->head;
            while (find == 0 && arg->node != NULL) {
                if (arg->node == oldSon) {
                    arg->node = newSon;
                    find = 1;
                }
                arg = arg->next;
            }
            if (find == 0)
                assert(0);
            break;
        case Constant:
            if (parent->content.constant.var == oldSon)
                parent->content.constant.var = newSon;
            else
                assert(0);
            break;
        default:
            assert(0);
    }
}

void FreeRC(Node *node) {
    RemoveHT(nodesHT, node);
    ListItem *listElement;
    switch (node->label) {
        case FVar:
            break;
        case BVar:
            break;
        case Piai:
            RefactoringSon(node->content.piai.var, node);
            RefactoringSon(node->content.piai.body, node);
            break;
        case Shared:
            RefactoringSon(node->content.shared.body, node);
            break;
        case App:
            RefactoringSon(node->content.app.left, node);
            RefactoringSon(node->content.app.right, node);
            break;
        case Lam:
            RefactoringSon(node->content.lam.body, node);
            RefactoringSon(node->content.lam.var, node);
            break;
        case Match:
            RefactoringSon(node->content.match.body, node);
            listElement = node->content.match.branches->head;
            while (listElement->node != NULL) {
                RefactoringSon(listElement->node, node);
                listElement = listElement->next;
            }
            break;
        case Let:
            RefactoringSon(node->content.let.t3, node);
            RefactoringSon(node->content.let.t2, node);
            RefactoringSon(node->content.let.var, node);
            break;
        case FRic:
            RefactoringSon(node->content.fRic.t, node);
            RefactoringSon(node->content.fRic.var, node);
            listElement = node->content.fRic.arg->head;
            while (listElement->node != NULL) {
                RefactoringSon(listElement->node, node);
                listElement = listElement->next;
            }
            break;
        case GCoRic:
            RefactoringSon(node->content.gCoRic.t, node);
            RefactoringSon(node->content.gCoRic.var, node);
            listElement = node->content.gCoRic.arg->head;
            while (listElement->node != NULL) {
                RefactoringSon(listElement->node, node);
                listElement = listElement->next;
            }
            break;
        case Constructor:
            listElement = node->content.jCostr.arg->head;
            while (listElement->node != NULL) {
                RefactoringSon(listElement->node, node);
                listElement = listElement->next;
            }
            break;
        case Constant:
            RefactoringSon(node->content.constant.var, node);
            break;
    }

    free(node);
}

void RefactoringSon(Node *node, Node *parent) {
    node->rc--;
    RemoveHT(node->parentNodes, parent);
    if (node->root == False && node->rc < 1)
        FreeRC(node);
}
\end{verbatim}
\section{Inst}
\begin{verbatim}
Node *Inst(Node *n, Node *l, Node *sub) {
    Node *n1;
    Node *temp;
    ListItem *iterList;
    struct List *arg = InitListHT();
    switch (n->label) {
        case FVar:
            return n;
        case BVar:
            if (n->content.bvar.binder == l)
                return InitShared(sub);
            else {
                if (n->content.bvar.binder->copy == NULL)
                    return n;
                else
                    return InitBVar(n->content.bvar.binder->copy);
            }
        case Piai:
            n1 = InitPiai(InitBVar(NULL), n->content.piai.body);
            n->copy = n1;
            temp = n1->content.piai.body;
            n1->content.piai.body = Inst(temp, l, sub);
            if (temp != n1->content.piai.body) {
                PushToListHT(n1->content.piai.body->parentNodes, n1);
                n1->content.piai.body->rc++;
                RemoveHT(temp->parentNodes, n1);
                temp->rc--;
            }
            n->copy = NULL;
            return n1;
        case Shared:
            return n;
        case App:
            return InitApp(Inst(n->content.app.left, l, sub), Inst(n->content.app.right, l, sub));
        case Lam:
            n1 = InitLam(InitBVar(NULL), n->content.lam.body);
            n->copy = n1;

            temp = n1->content.lam.body;
            n1->content.lam.body = Inst(temp, l, sub);
            if (temp != n1->content.lam.body) {
                PushToListHT(n1->content.lam.body->parentNodes, n1);
                n1->content.lam.body->rc++;
                RemoveHT(temp->parentNodes, n1);
                temp->rc--;
            }
            n->copy = NULL;
            return n1;
        case Match:
            return n;
        case Let:
            n1 = InitLet(InitBVar(NULL), n->content.let.t2, n->content.let.t3);
            n->copy = n1;
            temp = n1->content.let.t2;
            n1->content.let.t2 = Inst(temp, l, sub);
            if (temp != n1->content.let.t2) {
                PushToListHT(n1->content.let.t2->parentNodes, n1);
                n1->content.let.t2->rc++;
                RemoveHT(temp->parentNodes, n1);
                temp->rc--;
            }
            temp = n1->content.let.t3;
            n1->content.let.t3 = Inst(temp, l, sub);
            if (temp != n1->content.let.t3) {
                PushToListHT(n1->content.let.t3->parentNodes, n1);
                n1->content.let.t3->rc++;
                RemoveHT(temp->parentNodes, n1);
                temp->rc--;
            }
            n->copy = NULL;
            return n1;
        case FRic:
            iterList = n->content.fRic.arg->head;
            while (iterList->node != NULL) {
                PushToListHT(arg, iterList->node);
                iterList = iterList->next;
            }

            n1 = InitFRic(InitBVar(NULL), n->content.fRic.t, n->content.fRic.n, arg);
            n->copy = n1;
            temp = n1->content.fRic.t;
            n1->content.fRic.t = Inst(temp, l, sub);
            if (temp != n1->content.fRic.t) {
                PushToListHT(n1->content.fRic.t->parentNodes, n1);
                n1->content.fRic.t->rc++;
                RemoveHT(temp->parentNodes, n1);
                temp->rc--;
            }
            iterList = n1->content.fRic.arg->head;
            while (iterList->node != NULL) {
                temp = iterList->node;
                iterList->node = Inst(temp, l, sub);
                if (temp != iterList->node) {
                    PushToListHT(iterList->node->parentNodes, n1);
                    iterList->node->rc++;
                    RemoveHT(temp->parentNodes, n1);
                    temp->rc--;
                }
                iterList = iterList->next;
            }
            n->copy = NULL;
            return n1;
        case GCoRic:
            iterList = n->content.gCoRic.arg->head;
            while (iterList->node != NULL) {
                PushToListHT(arg, iterList->node);
                iterList = iterList->next;
            }
            n1 = InitGCoRic(InitBVar(NULL), n->content.gCoRic.t, n->content.gCoRic.n, arg);
            n->copy = n1;
            temp = n1->content.gCoRic.t;
            n1->content.gCoRic.t = Inst(temp, l, sub);
            if (temp != n1->content.gCoRic.t) {
                PushToListHT(n1->content.gCoRic.t->parentNodes, n1);
                n1->content.gCoRic.t->rc++;
                RemoveHT(temp->parentNodes, n1);
                temp->rc--;
            }
            iterList = n1->content.gCoRic.arg->head;
            while (iterList->node != NULL) {
                temp = iterList->node;
                iterList->node = Inst(temp, l, sub);
                if (temp != iterList->node) {
                    PushToListHT(iterList->node->parentNodes, n1);
                    iterList->node->rc++;
                    RemoveHT(temp->parentNodes, n1);
                    temp->rc--;
                }
                iterList = iterList->next;
            }
            n->copy = NULL;
            return n1;
        case Constructor:
            iterList = n->content.jCostr.arg->head;
            while (iterList->node != NULL) {
                PushToListHT(arg, iterList->node);
                iterList = iterList->next;
            }
            n1 = InitConstructor(n->content.jCostr.j, arg, n->content.jCostr.n);
            iterList = n1->content.jCostr.arg->head;
            while (iterList->node != NULL) {
                temp = iterList->node;
                iterList->node = Inst(temp, l, sub);
                if (temp != iterList->node) {
                    PushToListHT(iterList->node->parentNodes, n1);
                    iterList->node->rc++;
                    RemoveHT(temp->parentNodes, n1);
                    temp->rc--;
                }
                iterList = iterList->next;
            }
            return n1;
        case Constant:
            return n;
    }
}

\end{verbatim}
\section{AppReplacement}
\begin{verbatim}
Node *AppReplacement(Node *tj, List *args) {
    Node *result = tj;
    ListItem *arg = args->head;
    while (arg->node != NULL) {
        result = InitApp(result, arg->node);
        arg = arg->next;
    }
    return result;
}
\end{verbatim}


\clearpage{\pagestyle{empty}\cleardoublepage}
\begin{thebibliography}{90}             %crea l'ambiente bibliografia
\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
\thepage}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Bibliografia
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Bibliografia}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%provare anche questo comando:
%%%%%%%%%%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}
\bibitem{K1} AGGIUNGERE-RIFERIMENTO - Accattoli, Condoluci e Sacerdoti Coen, Sharing Equality is Linear.
\bibitem{K2} AGGIUNGERE-RIFERIMENTO - Accattoli e Dal Lago.
\bibitem{K3} M.S. Paterson and M.N. Wegman. 1978. Linear unification. J. Comput. System Sci. 16, 2 (1978), 158 - 167. https://doi.org/10.1016/0022-0000(78)90043-0.

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter*{Ringraziamenti}
\thispagestyle{empty}
Qui possiamo ringraziare il mondo intero!!!!!!!!!!\\
Ovviamente solo se uno vuole, non \`e obbligatorio.
\end{document}